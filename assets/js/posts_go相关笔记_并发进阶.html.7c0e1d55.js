"use strict";(self.webpackChunkvuepress_theme_hope_template=self.webpackChunkvuepress_theme_hope_template||[]).push([[9906],{2991:(s,i)=>{i.A=(s,i)=>{const n=s.__vccOpts||s;for(const[s,a]of i)n[s]=a;return n}},5363:(s,i,n)=>{n.r(i),n.d(i,{comp:()=>e,data:()=>h});var a=n(2360);const t=[(0,a.Fv)('<h1 id="并发进阶" tabindex="-1"><a class="header-anchor" href="#并发进阶"><span>并发进阶</span></a></h1><blockquote><p>本文为极客时间《Go语言核心36讲》的学习笔记，梳理了相关的知识点。</p></blockquote><p>通常情况下，我们是肯定不会直接起一个协程开始写逻辑代码的。Go语言已经帮我们写好了各种常用的并发工具，基本都在**sync（同步）**包中，可以开箱即用。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//正常情况下，是不会这样子直接起一个协程做并发业务的。</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">go</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">  ...</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>sync</strong>包里很多功能都是基于<strong>atomic</strong>来实现的。需要引申下Go的原子操作，以及底层实现原理，这里不做展开，内容不多，但需要使用到硬件相关的知识。</p></blockquote><p><a name="c88e1644"></a></p><h2 id="mutex和rwmutex" tabindex="-1"><a class="header-anchor" href="#mutex和rwmutex"><span>Mutex和RWMutex</span></a></h2><p>互斥锁和读写互斥锁是并发操作中最经常使用的，其底层的实现是基于<strong>atomic</strong>来实现的。并发场景保证数据一致性最经典的思路就是<strong>加锁</strong>，但加锁必定会导致程序性能的下降，使并行变成串行。因此，还有一种思维叫做<strong>无锁</strong>并发。</p><blockquote><p>引申，乐观锁与悲观锁是什么，会用在哪些场景中。</p></blockquote><p><a name="Mutex"></a></p><h3 id="mutex" tabindex="-1"><a class="header-anchor" href="#mutex"><span>Mutex</span></a></h3><p>互斥锁就像一个令牌，只有持有这个令牌的协程才可以操作具体的资源，其他协程只能等待，直到拿到这个令牌为止。举个例子：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">mu</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//加锁</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">_</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> writer</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Write</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">([]</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//操作某一块资源</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> err</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;error: </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">%s</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">mu</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//解锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用互斥锁的注意事项：</p><ul><li><strong>不要重复锁定互斥锁</strong>；</li></ul><p><strong>Mutex</strong>是不可重入锁，如果尝试对一个已经加锁的<strong>Mutex</strong>再次加锁，可能会导致协程陷入<strong>死锁</strong>。</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!</p></blockquote><p>在go语言中出现死锁会有这个报错。注意，这个报错的等级非常高，是系统层级的错误，无法被<strong>Recover</strong>回收，只要报出来，程序必然会崩溃。</p><blockquote><p>引申，Map的并发操作触发的Panic能否被回收？</p></blockquote><ul><li>**不要忘记解锁互斥锁，**必要时使用defer语句；</li></ul><p>正常情况下，**mu.Lock()<strong>和</strong>mu.Unlock()**一定是成对出现的，并且一定会使用defer语句。在具体写代码时有两个要求：</p><ol><li>严禁将一个锁用在多个资源上，一个资源加一把锁。这样不会出现冲突或者重复操作，但是会引入死锁的情况。</li><li>谁持有谁负责。加锁和解锁操作最好放在一个函数中，先加锁后解锁，避免因业务逻辑导致的死锁。</li></ol><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">mu</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Lock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//立马加锁，如果没有必要不要写业务逻辑。</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> mu</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//使用defer语句，延迟掉解锁操作</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//将业务逻辑都写在上述操作后面</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//这样子，任何逻辑下都不会有问题，依赖的是defer机制的保证。</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//这也是各大公司里明文要求的写法。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>不要对尚未锁定或者已解锁的互斥锁解锁</strong>；</li></ul><p>注意！解锁未锁定的互斥锁会立即引发<strong>panic</strong>，并且是一个严重的错误，无法被恢复，会导致程序直接崩溃。</p><ul><li><strong>不要在多个函数之间直接传递互斥锁</strong>。</li></ul><p>和我们之前讲过的情况一样。<strong>Mutex</strong>本质是一个结构体，和其他任何结构体一样，都存在传值还是指针的问题。因此，为了避免混淆，在开发中不要再多个函数中间传递<strong>Mutex</strong>，从源头上消灭这类问题。</p><p><a name="RWMutex"></a></p><h3 id="rwmutex" tabindex="-1"><a class="header-anchor" href="#rwmutex"><span>RWMutex</span></a></h3><p><strong>Mutex</strong>有一个问题，锁的粒度非常大，持有锁的人可以随便操作，没有锁的人就只能干等着。但实际业务中容易出现数据不一致的只有写操作，<strong>RWMutex</strong>再此基础上做了一点优化。 读写互斥锁本质上和互斥锁没有区别，只是贯彻了<strong>再加一层</strong>的思想，将互斥操作拆分为<strong>读操作</strong>和<strong>写操作</strong>。</p><blockquote><p>引申，在大多数互联网场景中都是读操作要远远大于写操作。</p></blockquote><p>我们直接抛出使用时的注意事项：</p><ol><li>多个<strong>写操作</strong>不能同时进行，<strong>写操作</strong>和<strong>读操作</strong>也不能同时进行，但多个<strong>读操作</strong>却可以同时进行。</li><li>对<strong>写锁进行解锁</strong>，会唤醒<strong>所有</strong>因试图锁定读锁，而被阻塞的goroutine。</li><li>对<strong>读锁进行解锁</strong>，只会在没有其他读锁锁定的前提下，唤醒“因试图锁定写锁，而被阻塞的 goroutine。</li></ol><p>日常中真正用的多的是<strong>RWMutex</strong>。</p><p><a name="Cond"></a></p><h2 id="cond" tabindex="-1"><a class="header-anchor" href="#cond"><span>Cond</span></a></h2><blockquote><p>这个组件很少很少用，正常情况下可以用Channel来平替，甚至有人讨论过，要不要去掉这个组件。它常见的场景是实现观察者模式</p></blockquote><p>这个组件的名字叫<strong>条件变量</strong>，其实干的就是信号通知的事情。 <strong>Cond的实现一定是依赖于互斥锁的</strong>。他只有三个方法：</p><ul><li><strong>wait</strong>让某个调用者进入Cond的等待队列里并阻塞，也就是进入了<strong>等待状态</strong>。</li><li><strong>signal</strong>让调用者唤醒<strong>一个</strong>等待Cond的协程。</li><li><strong>broadcast</strong>唤醒<strong>全部</strong>协程。</li></ul><p>我们这里不再展开<strong>Cond</strong>的具体用法，用的非常非常少，只有个别开源项目中有使用到。理论上，我们需要信号通知的场景完全可以使用<strong>Channel</strong>进行平替，<strong>Cond</strong>在此基础上再一次贯彻了<strong>加一层</strong>的思想，使程序不在依赖于具体的Channel。我们看下他们的区别：</p><ol><li><strong>Cond</strong>底层是依赖于<strong>Locker</strong>的，可以基于这一点做一些调整。Channel不具备这一点。</li><li><strong>Cond</strong>可以同时支持<strong>signal</strong>和<strong>broadcast</strong>，但是Channel只能同时支持一种，除非起多个。</li><li><strong>Cond</strong>可以重复使用。Channel一但关闭了，就不能再使用了。</li></ol><p><a name="WaitGroup"></a></p><h2 id="waitgroup" tabindex="-1"><a class="header-anchor" href="#waitgroup"><span>WaitGroup</span></a></h2><blockquote><p>这是日常开发中<strong>真正常用</strong>并发安全的组件。开箱即用，完全信赖。</p></blockquote><p><strong>WaitGroup</strong>主要用来对多个协程进行编排，<strong>让主协程可以等待所有子协程全部执行完毕后</strong>，再继续执行。它只有三个方法：Add，Done，Wait。我们直接看代码：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">wg</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> sync</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">WaitGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{} </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//起一个WaitGroup</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">wg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Add</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)              </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//计数器+1，注意这个方法必须在协程外执行，不能放到协程内。</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">go</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> fmt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;这是协程1！</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> wg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Done</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//协程执行完成，计数器-1，这个方法必须在协程内部使用。</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}()</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">wg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Add</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//同上</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">go</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> fmt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;这是协程2！</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> wg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Done</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//同上</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">wg</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Wait</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//主协程阻塞，直到计数器归零，说明子协程已经全部执行完成。</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> time</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">Second</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">fmt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Printf</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;这是主协程！</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，如果<strong>WaitGroup</strong>的计数器出现负值，会直接报出<strong>Panic</strong>，在使用中需要格外小心。就像上面的代码，通常我们调用Add，和Wait需要在同一个函数或者说，在同一个协程中。</p><blockquote><p>可以看下sync源码包里<strong>waitgroup_test.go</strong>文件，其中的名称以TestWaitGroupMisuse为前缀的测试函数，很好地展示了这些异常情况的发生条件。</p></blockquote><p><a name="Once"></a></p><h2 id="once" tabindex="-1"><a class="header-anchor" href="#once"><span>Once</span></a></h2><blockquote><p>功能单一，用的比较少，只有特殊场景才会使用。但是，越简单的东西，越实用。Once最常见的使用场景实现一个单例模式。</p></blockquote><p><strong>Once</strong>也是基于互斥锁实现的，在使用过程中也要注意传递问题。它只有一个方法Do，可以确保传入的方法<strong>仅仅只执行一次</strong>。注意事项：</p><ol><li>不要让<strong>Once</strong>执行一些耗时非常长或者有可能出现阻塞的方法，避免其他调用这个Once的协程被阻塞。</li><li><strong>Once</strong>不保证函数执行成功。无论函数是<strong>正常退出</strong>还是出现了<strong>Error</strong>或者<strong>Panic</strong>，都只会执行一次。</li></ol><p><a name="Pool"></a></p><h2 id="pool" tabindex="-1"><a class="header-anchor" href="#pool"><span>Pool</span></a></h2><blockquote><p>Pool在日常开发中极少使用，它提供的是一个<strong>临时对象池</strong>，存在安全隐患。我们常用的池化技术和它在思想上相同，在实现和使用上完全不一样，这点需要特别注意。</p></blockquote><p><strong>Pool</strong>只有三个方法：</p><ol><li><strong>New</strong> 用来创建一个新的元素。一般情况下，需要我们自己来实现一个方法创建一个元素。</li><li><strong>Get</strong> 用来获取一个元素。当取走这个元素时，<strong>Pool</strong>中会移除这个它。如果<strong>Pool</strong>里面没有元素了，就会调用<strong>New</strong>创建一个。这时候如果没有设置<strong>New</strong>，就会返回一个Nil。</li><li><strong>Put</strong> 向<strong>Pool</strong>中塞入一个元素，<strong>Pool</strong>会把他保存下来。如果塞入了一个nil，会直接忽略。</li></ol><p>它的具体实现非常复杂，和GMP调度模型有一些关联，我们这里就不展开了。 <strong>Pool</strong>存在内存泄露和内存浪费的问题，另外它有被清理的可能。日常开发中的池化技术通常会使用第三方包来实现。</p><blockquote><p>问题引申，我们常用的TCP连接池是怎样实现的。</p></blockquote><p><a name="Map"></a></p><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h2><p><strong>sync.Map</strong>要区别于Map。Go语言本身的Map是不具备并发安全的，这个我们之前写过，在广大开发者千呼万唤中，GO开发团队在1.9版本中发布了能够实现并发安全的<strong>sync.Map</strong>。 <strong>sync.Map</strong>的底层还是原生的Map，所以在键值的选择上依然不用<strong>函数类型、字典类型和切片类型</strong>。另外，如果让我们自己实现一个并发安全的Map，一定下意识的使用上面说的读写互斥锁。这个思路没有错，但<strong>只要加锁，必然降低效率</strong>。 <strong>sync.Map</strong>也有使用互斥锁，但核心操作全部都是原子操作。好处是性能较高，缺点是使用场景较少。按照官方的描述：</p><ol><li>只会增长的缓存系统中，一个 key 只写入一次而被读很多次。</li><li>多个 goroutine 为不相交的键集读、写和重写键值对。</li></ol><p>总而言之，Go自带的Map是不支持并发安全的，<strong>sync.Map</strong>有使用场景的限制，加锁又会显著的降低性能。在具体开发过程中，最好不要再并发中使用Map，如果一定要用，需要仔细分析当前的业务场景，选择合适的方案。</p><p><a name="25f9c7fa"></a></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>我们梳理了一些常见的并发同步工具，有些常用，有些特定情况下有用。Go语言的并发确实是一绝，但是日常开发中能不用就不用，能少用就少用。<strong>任何简单的场景，只要加入并发与异步都会变得相对复杂</strong>。</p><p>实事求是，量力而行。</p><p>引申阅读： <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/" target="_blank" rel="noopener noreferrer">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/</a></p>',70)],l={},e=(0,n(2991).A)(l,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,t)}]]),h=JSON.parse('{"path":"/posts/go%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6.html","title":"并发进阶","lang":"zh-CN","frontmatter":{"date":"2023-11-30T00:00:00.000Z","category":["后端","go语言","基础","并发"],"tag":["go","笔记","并发"],"author":"极客时间","icon":"devicon:go","description":"并发进阶 本文为极客时间《Go语言核心36讲》的学习笔记，梳理了相关的知识点。 通常情况下，我们是肯定不会直接起一个协程开始写逻辑代码的。Go语言已经帮我们写好了各种常用的并发工具，基本都在**sync（同步）**包中，可以开箱即用。 sync包里很多功能都是基于atomic来实现的。需要引申下Go的原子操作，以及底层实现原理，这里不做展开，内容不多，...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/go%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/%E5%B9%B6%E5%8F%91%E8%BF%9B%E9%98%B6.html"}],["meta",{"property":"og:site_name","content":"ik楠の空间"}],["meta",{"property":"og:title","content":"并发进阶"}],["meta",{"property":"og:description","content":"并发进阶 本文为极客时间《Go语言核心36讲》的学习笔记，梳理了相关的知识点。 通常情况下，我们是肯定不会直接起一个协程开始写逻辑代码的。Go语言已经帮我们写好了各种常用的并发工具，基本都在**sync（同步）**包中，可以开箱即用。 sync包里很多功能都是基于atomic来实现的。需要引申下Go的原子操作，以及底层实现原理，这里不做展开，内容不多，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-19T11:48:56.000Z"}],["meta",{"property":"article:author","content":"极客时间"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2023-11-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-19T11:48:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发进阶\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-30T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-19T11:48:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"极客时间\\"}]}"]]},"headers":[{"level":2,"title":"Mutex和RWMutex","slug":"mutex和rwmutex","link":"#mutex和rwmutex","children":[{"level":3,"title":"Mutex","slug":"mutex","link":"#mutex","children":[]},{"level":3,"title":"RWMutex","slug":"rwmutex","link":"#rwmutex","children":[]}]},{"level":2,"title":"Cond","slug":"cond","link":"#cond","children":[]},{"level":2,"title":"WaitGroup","slug":"waitgroup","link":"#waitgroup","children":[]},{"level":2,"title":"Once","slug":"once","link":"#once","children":[]},{"level":2,"title":"Pool","slug":"pool","link":"#pool","children":[]},{"level":2,"title":"Map","slug":"map","link":"#map","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1721389736000,"updatedTime":1721389736000,"contributors":[{"name":"iknan","email":"149158995+iknan@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":9.26,"words":2777},"filePathRelative":"posts/go相关笔记/并发进阶.md","localizedDate":"2023年11月30日","excerpt":"\\n<blockquote>\\n<p>本文为极客时间《Go语言核心36讲》的学习笔记，梳理了相关的知识点。</p>\\n</blockquote>\\n<p>通常情况下，我们是肯定不会直接起一个协程开始写逻辑代码的。Go语言已经帮我们写好了各种常用的并发工具，基本都在**sync（同步）**包中，可以开箱即用。</p>\\n<div class=\\"language-go line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"go\\" data-title=\\"go\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic\\">//正常情况下，是不会这样子直接起一个协程做并发业务的。</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">go</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\"> func</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(){</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#D73A49;--shiki-dark:#ABB2BF\\">  ...</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">.</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);